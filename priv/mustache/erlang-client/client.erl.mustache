{{=@@ @@=}}
%% File generated by erl-openapi on @@datetime@@.

-module(@@package_name@@).

-export([encode_q/4, encode_h/4]).

@@#exported_functions@@
-export([@@.@@/1, @@.@@/2]).
@@/exported_functions@@

@@#types@@
-export_type([@@name@@/0]).
@@/types@@

@@#types@@
@@def@@
@@/types@@

@@#functions@@
-spec @@f_name@@(@@f_name@@_request()) ->
        {ok, mhttp:response()} |
        {error, {mhttp, mhttp:error_reason()}} |
        {error, missing_content_type, mhttp:response()} |
        {error, {invalid_content_type, mhttp_media_type:error_reason()}, mhttp:response()}.
@@f_name@@(Args) ->
  @@f_name@@(Args, #{}).

-spec @@f_name@@(@@f_name@@_request(), mhttp:request_options()) ->
        {ok, mhttp:response()} |
        {error, {mhttp, mhttp:error_reason()}} |
        {error, missing_content_type, mhttp:response()} |
        {error, {invalid_content_type, mhttp_media_type:error_reason()}, mhttp:response()}.
@@f_name@@(Args, Options) ->
  @@#path_parameters@@
  Var@@pascal_name@@ = maps:get(@@snake_name@@, Args),
  @@/path_parameters@@
  Query = maps:get(query, Args, #{}),
  Header = maps:get(header, Args, #{}),
  EncodeQuery =
    fun
      @@#query_parameters@@
      ({@@snake_name@@, Value}) ->
        encode_q(@@style@@, @@explode@@, <<"@@real_name@@">>, Value);
      @@/query_parameters@@
      ({Key, Value}) ->
        [{Key, Value}]
    end,
  EncodeHeader =
    fun
      @@#header_parameters@@
      ({@@snake_name@@, Value}) ->
        encode_h(@@style@@, @@explode@@, <<"@@real_name@@">>, Value);
      @@/header_parameters@@
      ({Key, Value}) ->
        [{Key, Value}]
    end,
  ReqPath = io_lib:format("@@path_format@@", @@path_args@@),
  ReqQuery =
    lists:flatmap(EncodeQuery, maps:to_list(Query)),
  ReqHeader =
    lists:flatmap(EncodeHeader, maps:to_list(Header)),
  Req = #{method => @@method@@,
          header => ReqHeader,
          target => #{path => iolist_to_binary(ReqPath), query => ReqQuery}},
  case mhttp:send_request(Req, Options) of
    {ok, Resp} ->
      RespHeader = mhttp_response:header(Resp),
      case mhttp_header:find(RespHeader, <<"Content-Type">>) of
        {ok, MediaTypeValue} ->
          case mhttp_media_type:parse(MediaTypeValue) of
            {ok, _} ->
              {ok, Resp};
            {error, Reason} ->
              {error, {invalid_content_type, Reason}, Resp}
          end;
        error ->
          {error, missing_content_type, Resp}
      end;
    {error, Reason} ->
      {error, {mhttp, Reason}}
  end.
@@/functions@@

-spec encode_q(Style, Explode, Key, Value) -> uri:query()
          when Style :: form | spaceDelimitde | pipeDelimited | deepObject,
               Explode :: boolean(),
               Key :: binary(),
               Value :: term().
encode_q(form, true, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_q(form, true, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_q(form, true, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_q(form, true, Key, Values) when is_list(Values) ->
  lists:map(
    fun
      (Value) when is_binary(Value) -> {Key, Value};
      (Value) when is_integer(Value) -> {Key, integer_to_binary(Value)};
      (Value) when is_atom(Value) -> {Key, atom_to_binary(Value)}
    end, Values);
encode_q(form, true, _Key, Values) when is_map(Values) ->
  maps:fold(
    fun
      (Key, Value, Acc) when is_binary(Value) ->
        [{Key, Value} | Acc];
      (Key, Value, Acc) when is_integer(Value) ->
        [{Key, integer_to_binary(Value)} | Acc];
      (Key, Value, Acc) when is_atom(Value) ->
        [{Key, atom_to_binary(Key)} | Acc]
    end, [], Values);

encode_q(form, false, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_q(form, false, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_q(form, false, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_q(form, false, Key, Values) when is_list(Values) ->
  Values1 =
    lists:map(
      fun
        (Value) when is_binary(Value) -> Value;
        (Value) when is_integer(Value) -> integer_to_binary(Value);
        (Value) when is_atom(Value) -> atom_to_binary(Value)
      end, Values),
  [{Key, unicode:characters_to_binary(lists:join(",", Values1))}];
encode_q(form, false, Key, Values) when is_map(Values) ->
  Values1 =
    maps:fold(
      fun
        (K, V, Acc) when is_binary(V) ->
          [[K, $,, V] | Acc];
        (K, V, Acc) when is_integer(V) ->
          [[K, $,, integer_to_binary(V)] | Acc];
        (K, V, Acc) when is_atom(V) ->
          [[K, $,, atom_to_binary(V)] | Acc]
      end, [], Values),
  [{Key, unicode:characters_to_binary(lists:join(",", Values1))}];

%% deepObject MUST not encode primary or array value but Stripe use this style
%% to encode query parameter. So I'm force to extend the spec.
encode_q(deepObject, true, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_q(deepObject, true, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_q(deepObject, true, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_q(deepObject, true, Key, Values) when is_list(Values) ->
  lists:map(
    fun
      (Value) when is_binary(Value)->
        {<<Key/binary, "[]">>, Value};
      (Value) when is_integer(Value) ->
        {<<Key/binary, "[]">>, integer_to_binary(Value)};
      (Value) when is_atom(Value) ->
        {<<Key/binary, "[]">>, atom_to_binary(Value)}
    end, Values);
encode_q(deepObject, true, Key, Values) when is_map(Values) ->
  maps:fold(
    fun
      (K, V, Acc) when is_binary(V) ->
        K2 = atom_to_binary(K),
        [{<<Key/binary, $[, K2/binary, $]>>, V} | Acc];
      (K, V, Acc) when is_integer(V) ->
        K2 = atom_to_binary(K),
        [{<<Key/binary, $[, K2/binary, $]>>, integer_to_binary(V)} | Acc];
      (K, V, Acc) when is_atom(V) ->
        K2 = atom_to_binary(K),
        [{<<Key/binary, $[, K2/binary, $]>>, atom_to_binary(V)} | Acc]
    end, [], Values).

-spec encode_h(Style, Explode, Key, Value) -> mhttp:header()
          when Style :: simple,
               Explode :: boolean(),
               Key :: binary(),
               Value :: term().
encode_h(simple, false, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_h(simple, false, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_h(simple, false, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_h(simple, false, Key, Values) when is_list(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        lists:map(
          fun
            (Value) when is_binary(Value) -> Value;
            (Value) when is_integer(Value) -> integer_to_binary(Value);
            (Value) when is_atom(Value) -> atom_to_binary(Value)
          end, Values)))}];
encode_h(simple, false, Key, Values) when is_map(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        maps:fold(
          fun
            (K, V, Acc) when is_binary(V) ->
              [[K, $,, V] | Acc];
            (K, V, Acc) when is_integer(V) ->
              [[K, $,, integer_to_binary(V)] | Acc];
            (K, V, Acc) when is_atom(V) ->
              [[K, $,, atom_to_binary(V)] | Acc]
          end, [], Values)))}];

encode_h(simple, true, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_h(simple, true, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_h(simple, true, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_h(simple, true, Key, Values) when is_list(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        lists:map(
          fun
            (Value) when is_binary(Value) -> Value;
            (Value) when is_integer(Value) -> integer_to_binary(Value);
            (Value) when is_atom(Value) -> atom_to_binary(Value)
          end, Values)))}];
encode_h(simple, true, Key, Values) when is_map(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        maps:fold(
          fun
            (K, V, Acc) when is_binary(V) ->
              [[K, $=, V] | Acc];
            (K, V, Acc) when is_integer(V) ->
              [[K, $=, integer_to_binary(V)] | Acc];
            (K, V, Acc) when is_atom(V) ->
              [[K, $=, atom_to_binary(V)] | Acc]
          end, [], Values)))}].
