%% Copyright (c) 2021-2022 Exograd SAS.
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
%% SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
%% IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-module(openapi_erlang_client_code_gen).

-import(prettypr,
        [text/1,
         nest/2,
         above/2,
         beside/2,
         sep/1,
         par/1,
         par/2,
         floating/3,
         floating/1,
         break/1,
         follow/2,
         follow/3,
         empty/0]).

-export_type([error_reason/0]).

-export([generate/3]).

-type error_reason() :: term().

-spec generate(openapi:specification(), file:name_all(),
               openapi:generate_options()) ->
        ok | {error, error_reason()}.
generate(Spec, OutDir, Options) ->
  Now = os:system_time(second),
  Datetime = calendar:system_time_to_rfc3339(Now, [{offset, "Z"}]),
  PackageName = maps:get(package_name, Options),
  Data = #{datetime => Datetime,
           package_name => <<PackageName/binary, "_openapi">>,
           functions => [info_fun_0(Spec), servers_fun_0(Spec)]},
  File = openapi_mustache:render(<<"erlang-client/openapi.erl">>, Data),
  io:format("~s", [File]).

-spec info_fun_0(openapi:specification()) -> binary().
info_fun_0(#{info := Info}) ->
  Data = io_lib:format("~p.", [Info]),
  Lines = string:split(Data, "\n", all),
  Documents = lists:map(fun (Line) -> text(Line) end, Lines),
  iolist_to_binary(
    prettypr:format(
      sep(
        [beside(
           break(text("-spec info() -> info().")),
           break(text("info() ->"))),
         nest(4, beside(
                   sep(Documents),
                   empty())),
         empty()]))).

-spec servers_fun_0(openapi:specification()) -> iodata().
servers_fun_0(#{servers := Servers}) ->
  Data = io_lib:format("~p.", [Servers]),
  Lines = string:split(Data, "\n", all),
  Documents = lists:map(fun (Line) -> text(Line) end, Lines),
  iolist_to_binary(
    prettypr:format(
      sep(
        [beside(
           break(text("-spec servers() -> [server()].")),
           break(text("servers() ->"))),
         nest(4, beside(
                   sep(Documents),
                   empty())),
         empty()])));
servers_fun_0(_) ->
  "".

%% schemas(none, #{type := T} = State) ->
%%   State#{type => lists:reverse(T)};
%% schemas({Name, Definition, Iterator}, #{index := I} = State) ->
%%   NewName = openapi_generator:to_snake_case(Name),
%%   State2 =
%%     State#{index => I#{Name => NewName}},
%%   schemas(maps:next(Iterator), State2).
%%
%% -spec header_line() -> iodata().
%% header_line() ->
%%   Now = os:system_time(second),
%%   Datetime = calendar:system_time_to_rfc3339(Now, [{offset, "Z"}]),
%%   Line = ["File generated by erl-openapi on ", Datetime, "."],
%%   [comment(Line)].
%%
%% -spec comment(iodata()) -> iodata().
%% comment(Lines) ->
%%   F = fun (Line) ->
%%           case unicode:characters_to_list(Line) of
%%             "" ->
%%               prettypr:break(prettypr:text(""));
%%             String ->
%%               prettypr:text_par(String)
%%           end
%%       end,
%%   Paragraphs = lists:map(F, string:split(Lines, "\n", all)),
%%   FilledText = prettypr:format(prettypr:sep(Paragraphs), 77),
%%   ["%% ", string:replace(FilledText, "\n", "\n%% ", all), $\n].
%%
%% define_types(Index) ->
%%   L = lists:map(fun (Name) -> type(Name, {"json", "value"}) end, maps:values(Index)),
%%   lists:join("\n", L).
%%
%% type(Name, {Module, Type}) ->
%%   ["-type ", Name, "() :: ", Module, ":", Type, "().\n"];
%% type(Name, Type) ->
%%   ["-type ", Name, "() :: ", Type, "().\n"].
%%
%% export_types(Types) ->
%%   ["-export_type([",
%%    lists:join(["/0,\n", indent(14)], maps:values(Types)),
%%    "].\n"].
%%
%% -spec newline() -> char().
%% newline() ->
%%   $\n.
%%
%% -spec indent(pos_integer()) -> iodata().
%% indent(Size) ->
%%   lists:map(fun (_) -> $\s end, lists:seq(1, Size)).
